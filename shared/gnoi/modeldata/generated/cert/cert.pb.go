// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/openconfig/gnoi/cert/cert.proto

/*
Package gnoi_certificate is a generated protocol buffer package.

It is generated from these files:
        github.com/openconfig/gnoi/cert/cert.proto

It has these top-level messages:
        RotateCertificateRequest
        RotateCertificateResponse
        InstallCertificateRequest
        InstallCertificateResponse
        GenerateCSRRequest
        CSRParams
        GenerateCSRResponse
        LoadCertificateRequest
        LoadCertificateResponse
        FinalizeRequest
        GetCertificatesRequest
        GetCertificatesResponse
        CertificateInfo
        RevokeCertificatesRequest
        RevokeCertificatesResponse
        CertificateRevocationError
        CanGenerateCSRRequest
        CanGenerateCSRResponse
        Certificate
        CSR
        KeyPair
        Endpoint
*/
package cert

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/openconfig/gnoi/types"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Types of certificates.
type CertificateType int32

const (
	// 1 - 500 for public use.
	// 501 onwards for private use.
	CertificateType_CT_UNKNOWN CertificateType = 0
	CertificateType_CT_X509    CertificateType = 1
)

var CertificateType_name = map[int32]string{
	0: "CT_UNKNOWN",
	1: "CT_X509",
}
var CertificateType_value = map[string]int32{
	"CT_UNKNOWN": 0,
	"CT_X509":    1,
}

func (x CertificateType) String() string {
	return proto.EnumName(CertificateType_name, int32(x))
}
func (CertificateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Algorithm to be used for generation the key pair.
type KeyType int32

const (
	// 1 - 500, for known types.
	// 501 and onwards for private use.
	KeyType_KT_UNKNOWN KeyType = 0
	KeyType_KT_RSA     KeyType = 1
)

var KeyType_name = map[int32]string{
	0: "KT_UNKNOWN",
	1: "KT_RSA",
}
var KeyType_value = map[string]int32{
	"KT_UNKNOWN": 0,
	"KT_RSA":     1,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}
func (KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Type of endpoint that can use a cert. This list is to be extended based on
// conversation with vendors.
type Endpoint_Type int32

const (
	Endpoint_EP_UNSPECIFIED  Endpoint_Type = 0
	Endpoint_EP_IPSEC_TUNNEL Endpoint_Type = 1
	Endpoint_EP_DAEMON       Endpoint_Type = 2
)

var Endpoint_Type_name = map[int32]string{
	0: "EP_UNSPECIFIED",
	1: "EP_IPSEC_TUNNEL",
	2: "EP_DAEMON",
}
var Endpoint_Type_value = map[string]int32{
	"EP_UNSPECIFIED":  0,
	"EP_IPSEC_TUNNEL": 1,
	"EP_DAEMON":       2,
}

func (x Endpoint_Type) String() string {
	return proto.EnumName(Endpoint_Type_name, int32(x))
}
func (Endpoint_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

// Request messages to rotate existing certificates on the target.
type RotateCertificateRequest struct {
	// Request Messages.
	//
	// Types that are valid to be assigned to RotateRequest:
	//      *RotateCertificateRequest_GenerateCsr
	//      *RotateCertificateRequest_LoadCertificate
	//      *RotateCertificateRequest_FinalizeRotation
	RotateRequest isRotateCertificateRequest_RotateRequest `protobuf_oneof:"rotate_request"`
}

func (m *RotateCertificateRequest) Reset()                    { *m = RotateCertificateRequest{} }
func (m *RotateCertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*RotateCertificateRequest) ProtoMessage()               {}
func (*RotateCertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isRotateCertificateRequest_RotateRequest interface{ isRotateCertificateRequest_RotateRequest() }

type RotateCertificateRequest_GenerateCsr struct {
	GenerateCsr *GenerateCSRRequest `protobuf:"bytes,1,opt,name=generate_csr,json=generateCsr,oneof"`
}
type RotateCertificateRequest_LoadCertificate struct {
	LoadCertificate *LoadCertificateRequest `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}
type RotateCertificateRequest_FinalizeRotation struct {
	FinalizeRotation *FinalizeRequest `protobuf:"bytes,3,opt,name=finalize_rotation,json=finalizeRotation,oneof"`
}

func (*RotateCertificateRequest_GenerateCsr) isRotateCertificateRequest_RotateRequest()      {}
func (*RotateCertificateRequest_LoadCertificate) isRotateCertificateRequest_RotateRequest()  {}
func (*RotateCertificateRequest_FinalizeRotation) isRotateCertificateRequest_RotateRequest() {}

func (m *RotateCertificateRequest) GetRotateRequest() isRotateCertificateRequest_RotateRequest {
	if m != nil {
		return m.RotateRequest
	}
	return nil
}

func (m *RotateCertificateRequest) GetGenerateCsr() *GenerateCSRRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_GenerateCsr); ok {
		return x.GenerateCsr
	}
	return nil
}

func (m *RotateCertificateRequest) GetLoadCertificate() *LoadCertificateRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

func (m *RotateCertificateRequest) GetFinalizeRotation() *FinalizeRequest {
	if x, ok := m.GetRotateRequest().(*RotateCertificateRequest_FinalizeRotation); ok {
		return x.FinalizeRotation
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateCertificateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateCertificateRequest_OneofMarshaler, _RotateCertificateRequest_OneofUnmarshaler, _RotateCertificateRequest_OneofSizer, []interface{}{
		(*RotateCertificateRequest_GenerateCsr)(nil),
		(*RotateCertificateRequest_LoadCertificate)(nil),
		(*RotateCertificateRequest_FinalizeRotation)(nil),
	}
}

func _RotateCertificateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateCertificateRequest)
	// rotate_request
	switch x := m.RotateRequest.(type) {
	case *RotateCertificateRequest_GenerateCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenerateCsr); err != nil {
			return err
		}
	case *RotateCertificateRequest_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case *RotateCertificateRequest_FinalizeRotation:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FinalizeRotation); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RotateCertificateRequest.RotateRequest has unexpected type %T", x)
	}
	return nil
}

func _RotateCertificateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateCertificateRequest)
	switch tag {
	case 1: // rotate_request.generate_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_GenerateCsr{msg}
		return true, err
	case 2: // rotate_request.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_LoadCertificate{msg}
		return true, err
	case 3: // rotate_request.finalize_rotation
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FinalizeRequest)
		err := b.DecodeMessage(msg)
		m.RotateRequest = &RotateCertificateRequest_FinalizeRotation{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RotateCertificateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateCertificateRequest)
	// rotate_request
	switch x := m.RotateRequest.(type) {
	case *RotateCertificateRequest_GenerateCsr:
		s := proto.Size(x.GenerateCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateRequest_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateRequest_FinalizeRotation:
		s := proto.Size(x.FinalizeRotation)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response Messages from the target.
type RotateCertificateResponse struct {
	// Response messages.
	//
	// Types that are valid to be assigned to RotateResponse:
	//      *RotateCertificateResponse_GeneratedCsr
	//      *RotateCertificateResponse_LoadCertificate
	RotateResponse isRotateCertificateResponse_RotateResponse `protobuf_oneof:"rotate_response"`
}

func (m *RotateCertificateResponse) Reset()                    { *m = RotateCertificateResponse{} }
func (m *RotateCertificateResponse) String() string            { return proto.CompactTextString(m) }
func (*RotateCertificateResponse) ProtoMessage()               {}
func (*RotateCertificateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isRotateCertificateResponse_RotateResponse interface{ isRotateCertificateResponse_RotateResponse() }

type RotateCertificateResponse_GeneratedCsr struct {
	GeneratedCsr *GenerateCSRResponse `protobuf:"bytes,1,opt,name=generated_csr,json=generatedCsr,oneof"`
}
type RotateCertificateResponse_LoadCertificate struct {
	LoadCertificate *LoadCertificateResponse `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}

func (*RotateCertificateResponse_GeneratedCsr) isRotateCertificateResponse_RotateResponse()    {}
func (*RotateCertificateResponse_LoadCertificate) isRotateCertificateResponse_RotateResponse() {}

func (m *RotateCertificateResponse) GetRotateResponse() isRotateCertificateResponse_RotateResponse {
	if m != nil {
		return m.RotateResponse
	}
	return nil
}

func (m *RotateCertificateResponse) GetGeneratedCsr() *GenerateCSRResponse {
	if x, ok := m.GetRotateResponse().(*RotateCertificateResponse_GeneratedCsr); ok {
		return x.GeneratedCsr
	}
	return nil
}

func (m *RotateCertificateResponse) GetLoadCertificate() *LoadCertificateResponse {
	if x, ok := m.GetRotateResponse().(*RotateCertificateResponse_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RotateCertificateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RotateCertificateResponse_OneofMarshaler, _RotateCertificateResponse_OneofUnmarshaler, _RotateCertificateResponse_OneofSizer, []interface{}{
		(*RotateCertificateResponse_GeneratedCsr)(nil),
		(*RotateCertificateResponse_LoadCertificate)(nil),
	}
}

func _RotateCertificateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RotateCertificateResponse)
	// rotate_response
	switch x := m.RotateResponse.(type) {
	case *RotateCertificateResponse_GeneratedCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneratedCsr); err != nil {
			return err
		}
	case *RotateCertificateResponse_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RotateCertificateResponse.RotateResponse has unexpected type %T", x)
	}
	return nil
}

func _RotateCertificateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RotateCertificateResponse)
	switch tag {
	case 1: // rotate_response.generated_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRResponse)
		err := b.DecodeMessage(msg)
		m.RotateResponse = &RotateCertificateResponse_GeneratedCsr{msg}
		return true, err
	case 2: // rotate_response.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateResponse)
		err := b.DecodeMessage(msg)
		m.RotateResponse = &RotateCertificateResponse_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RotateCertificateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RotateCertificateResponse)
	// rotate_response
	switch x := m.RotateResponse.(type) {
	case *RotateCertificateResponse_GeneratedCsr:
		s := proto.Size(x.GeneratedCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RotateCertificateResponse_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request messages to install new certificates on the target.
type InstallCertificateRequest struct {
	// Request Messages.
	//
	// Types that are valid to be assigned to InstallRequest:
	//      *InstallCertificateRequest_GenerateCsr
	//      *InstallCertificateRequest_LoadCertificate
	InstallRequest isInstallCertificateRequest_InstallRequest `protobuf_oneof:"install_request"`
}

func (m *InstallCertificateRequest) Reset()                    { *m = InstallCertificateRequest{} }
func (m *InstallCertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*InstallCertificateRequest) ProtoMessage()               {}
func (*InstallCertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isInstallCertificateRequest_InstallRequest interface{ isInstallCertificateRequest_InstallRequest() }

type InstallCertificateRequest_GenerateCsr struct {
	GenerateCsr *GenerateCSRRequest `protobuf:"bytes,1,opt,name=generate_csr,json=generateCsr,oneof"`
}
type InstallCertificateRequest_LoadCertificate struct {
	LoadCertificate *LoadCertificateRequest `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}

func (*InstallCertificateRequest_GenerateCsr) isInstallCertificateRequest_InstallRequest()     {}
func (*InstallCertificateRequest_LoadCertificate) isInstallCertificateRequest_InstallRequest() {}

func (m *InstallCertificateRequest) GetInstallRequest() isInstallCertificateRequest_InstallRequest {
	if m != nil {
		return m.InstallRequest
	}
	return nil
}

func (m *InstallCertificateRequest) GetGenerateCsr() *GenerateCSRRequest {
	if x, ok := m.GetInstallRequest().(*InstallCertificateRequest_GenerateCsr); ok {
		return x.GenerateCsr
	}
	return nil
}

func (m *InstallCertificateRequest) GetLoadCertificate() *LoadCertificateRequest {
	if x, ok := m.GetInstallRequest().(*InstallCertificateRequest_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallCertificateRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallCertificateRequest_OneofMarshaler, _InstallCertificateRequest_OneofUnmarshaler, _InstallCertificateRequest_OneofSizer, []interface{}{
		(*InstallCertificateRequest_GenerateCsr)(nil),
		(*InstallCertificateRequest_LoadCertificate)(nil),
	}
}

func _InstallCertificateRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallCertificateRequest)
	// install_request
	switch x := m.InstallRequest.(type) {
	case *InstallCertificateRequest_GenerateCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GenerateCsr); err != nil {
			return err
		}
	case *InstallCertificateRequest_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallCertificateRequest.InstallRequest has unexpected type %T", x)
	}
	return nil
}

func _InstallCertificateRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallCertificateRequest)
	switch tag {
	case 1: // install_request.generate_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRRequest)
		err := b.DecodeMessage(msg)
		m.InstallRequest = &InstallCertificateRequest_GenerateCsr{msg}
		return true, err
	case 2: // install_request.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateRequest)
		err := b.DecodeMessage(msg)
		m.InstallRequest = &InstallCertificateRequest_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallCertificateRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallCertificateRequest)
	// install_request
	switch x := m.InstallRequest.(type) {
	case *InstallCertificateRequest_GenerateCsr:
		s := proto.Size(x.GenerateCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallCertificateRequest_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Response Messages from the target for the InstallCertificateRequest.
type InstallCertificateResponse struct {
	// Response messages.
	//
	// Types that are valid to be assigned to InstallResponse:
	//      *InstallCertificateResponse_GeneratedCsr
	//      *InstallCertificateResponse_LoadCertificate
	InstallResponse isInstallCertificateResponse_InstallResponse `protobuf_oneof:"install_response"`
}

func (m *InstallCertificateResponse) Reset()                    { *m = InstallCertificateResponse{} }
func (m *InstallCertificateResponse) String() string            { return proto.CompactTextString(m) }
func (*InstallCertificateResponse) ProtoMessage()               {}
func (*InstallCertificateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isInstallCertificateResponse_InstallResponse interface{ isInstallCertificateResponse_InstallResponse() }

type InstallCertificateResponse_GeneratedCsr struct {
	GeneratedCsr *GenerateCSRResponse `protobuf:"bytes,1,opt,name=generated_csr,json=generatedCsr,oneof"`
}
type InstallCertificateResponse_LoadCertificate struct {
	LoadCertificate *LoadCertificateResponse `protobuf:"bytes,2,opt,name=load_certificate,json=loadCertificate,oneof"`
}

func (*InstallCertificateResponse_GeneratedCsr) isInstallCertificateResponse_InstallResponse()    {}
func (*InstallCertificateResponse_LoadCertificate) isInstallCertificateResponse_InstallResponse() {}

func (m *InstallCertificateResponse) GetInstallResponse() isInstallCertificateResponse_InstallResponse {
	if m != nil {
		return m.InstallResponse
	}
	return nil
}

func (m *InstallCertificateResponse) GetGeneratedCsr() *GenerateCSRResponse {
	if x, ok := m.GetInstallResponse().(*InstallCertificateResponse_GeneratedCsr); ok {
		return x.GeneratedCsr
	}
	return nil
}

func (m *InstallCertificateResponse) GetLoadCertificate() *LoadCertificateResponse {
	if x, ok := m.GetInstallResponse().(*InstallCertificateResponse_LoadCertificate); ok {
		return x.LoadCertificate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InstallCertificateResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InstallCertificateResponse_OneofMarshaler, _InstallCertificateResponse_OneofUnmarshaler, _InstallCertificateResponse_OneofSizer, []interface{}{
		(*InstallCertificateResponse_GeneratedCsr)(nil),
		(*InstallCertificateResponse_LoadCertificate)(nil),
	}
}

func _InstallCertificateResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InstallCertificateResponse)
	// install_response
	switch x := m.InstallResponse.(type) {
	case *InstallCertificateResponse_GeneratedCsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GeneratedCsr); err != nil {
			return err
		}
	case *InstallCertificateResponse_LoadCertificate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LoadCertificate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("InstallCertificateResponse.InstallResponse has unexpected type %T", x)
	}
	return nil
}

func _InstallCertificateResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InstallCertificateResponse)
	switch tag {
	case 1: // install_response.generated_csr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GenerateCSRResponse)
		err := b.DecodeMessage(msg)
		m.InstallResponse = &InstallCertificateResponse_GeneratedCsr{msg}
		return true, err
	case 2: // install_response.load_certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadCertificateResponse)
		err := b.DecodeMessage(msg)
		m.InstallResponse = &InstallCertificateResponse_LoadCertificate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _InstallCertificateResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InstallCertificateResponse)
	// install_response
	switch x := m.InstallResponse.(type) {
	case *InstallCertificateResponse_GeneratedCsr:
		s := proto.Size(x.GeneratedCsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InstallCertificateResponse_LoadCertificate:
		s := proto.Size(x.LoadCertificate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request to generate the CSR.
// When this request is made for rotating an existing certificate as part of the
// Rotate() RPC, then the target must ensure that the "certificate_id" is
// already created and exists on the target. If the Certificate Rotation
// proceeds to load the certificate, it must associate the new certificate with
// the previously created "certificate_id".
//
// When this request is made for installing a completely new certificate as part
// of the Install() RPC , then the target must ensure that the "certificate_id"
// is completely new and no entities on the target are should be bound to this
// certificate_id. If any existing certificate matches the certificate_id, then
// this request should fail.
//
// If there is another ongoing Rotate/Install RPC with the same certificate_id,
// the GenerateCSRRequest should fail.
type GenerateCSRRequest struct {
	// Parameters for creating a CSR.
	CsrParams *CSRParams `protobuf:"bytes,1,opt,name=csr_params,json=csrParams" json:"csr_params,omitempty"`
	// The certificate id with which this CSR will be associated. The target
	// configuration should bind an entity which wants to use a certificate to
	// the certificate_id it should use.
	CertificateId string `protobuf:"bytes,2,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
}

func (m *GenerateCSRRequest) Reset()                    { *m = GenerateCSRRequest{} }
func (m *GenerateCSRRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateCSRRequest) ProtoMessage()               {}
func (*GenerateCSRRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GenerateCSRRequest) GetCsrParams() *CSRParams {
	if m != nil {
		return m.CsrParams
	}
	return nil
}

func (m *GenerateCSRRequest) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

// Parameters to be used when generating a Certificate Signing Request.
type CSRParams struct {
	// The type of certificate which will be associated for this CSR.
	Type CertificateType `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Minimum size of the key to be used by the target when generating a
	// public/private key pair.
	MinKeySize uint32 `protobuf:"varint,2,opt,name=min_key_size,json=minKeySize" json:"min_key_size,omitempty"`
	// If provided, the target must use the provided key type. If the target
	// cannot use the algorithm specified in the key_type, it should cancel the
	// stream with an Unimplemented error.
	KeyType KeyType `protobuf:"varint,3,opt,name=key_type,json=keyType,enum=gnoi.certificate.KeyType" json:"key_type,omitempty"`
	// --- common set of parameters applicable for any type of certificate --- //
	CommonName         string `protobuf:"bytes,4,opt,name=common_name,json=commonName" json:"common_name,omitempty"`
	Country            string `protobuf:"bytes,5,opt,name=country" json:"country,omitempty"`
	State              string `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
	City               string `protobuf:"bytes,7,opt,name=city" json:"city,omitempty"`
	Organization       string `protobuf:"bytes,8,opt,name=organization" json:"organization,omitempty"`
	OrganizationalUnit string `protobuf:"bytes,9,opt,name=organizational_unit,json=organizationalUnit" json:"organizational_unit,omitempty"`
	IpAddress          string `protobuf:"bytes,10,opt,name=ip_address,json=ipAddress" json:"ip_address,omitempty"`
	EmailId            string `protobuf:"bytes,11,opt,name=email_id,json=emailId" json:"email_id,omitempty"`
}

func (m *CSRParams) Reset()                    { *m = CSRParams{} }
func (m *CSRParams) String() string            { return proto.CompactTextString(m) }
func (*CSRParams) ProtoMessage()               {}
func (*CSRParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CSRParams) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CSRParams) GetMinKeySize() uint32 {
	if m != nil {
		return m.MinKeySize
	}
	return 0
}

func (m *CSRParams) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_KT_UNKNOWN
}

func (m *CSRParams) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

func (m *CSRParams) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *CSRParams) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *CSRParams) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *CSRParams) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *CSRParams) GetOrganizationalUnit() string {
	if m != nil {
		return m.OrganizationalUnit
	}
	return ""
}

func (m *CSRParams) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *CSRParams) GetEmailId() string {
	if m != nil {
		return m.EmailId
	}
	return ""
}

// GenerateCSRResponse contains the CSR associated with the Certificate ID
// supplied in the GenerateCSRRequest. When a Certificate is subsequently
// installed on the target in the same streaming RPC session, it must be
// associated to that Certificate ID.
//
// An Unimplemented error will be returned if the target cannot generate a CSR
// as per the request. In this case, the caller must generate its own key pair.
type GenerateCSRResponse struct {
	Csr *CSR `protobuf:"bytes,1,opt,name=csr" json:"csr,omitempty"`
}

func (m *GenerateCSRResponse) Reset()                    { *m = GenerateCSRResponse{} }
func (m *GenerateCSRResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateCSRResponse) ProtoMessage()               {}
func (*GenerateCSRResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GenerateCSRResponse) GetCsr() *CSR {
	if m != nil {
		return m.Csr
	}
	return nil
}

// LoadCertificateRequest instructs the target to store the given certificate.
//
// Case 1: Target Generated CSR and Key Pair.
// If the target generated the CSR (and the public/private key pair) during the
// GenerateCSR request, then the target must associate the certificate with the
// certificate ID specified in the preceding GenerateCSR request.
//
// Case 2: Externally Generated Key Pair.
// If the target can not generate a CSR, then the public/private key pair is
// generated externally. In this case provide the target with the key pair,
// and the certificate_id to be associated with the new certificate.
//
// If there is another ongoing Rotate/Install RPC with the same certificate_id,
// the LoadCertificateRequest must fail.
type LoadCertificateRequest struct {
	// The certificate to be Loaded on the target.
	Certificate *Certificate `protobuf:"bytes,1,opt,name=certificate" json:"certificate,omitempty"`
	// The key pair to be used with the certificate. This is provided in the event
	// that the target cannot generate a CSR (and the corresponding public/private
	// keys).
	KeyPair *KeyPair `protobuf:"bytes,2,opt,name=key_pair,json=keyPair" json:"key_pair,omitempty"`
	// Certificate Id of the above certificate. This is to be provided only when
	// there is an externally generated key pair.
	CertificateId string `protobuf:"bytes,3,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
	// Optional bundle of CA certificates. When not empty, the provided
	// certificates should squash the existing bundle. This field provides a
	// simplified means to provision a CA bundle that can be used to validate
	// other peer's certificates.
	CaCertificates []*Certificate `protobuf:"bytes,4,rep,name=ca_certificates,json=caCertificates" json:"ca_certificates,omitempty"`
}

func (m *LoadCertificateRequest) Reset()                    { *m = LoadCertificateRequest{} }
func (m *LoadCertificateRequest) String() string            { return proto.CompactTextString(m) }
func (*LoadCertificateRequest) ProtoMessage()               {}
func (*LoadCertificateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LoadCertificateRequest) GetCertificate() *Certificate {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *LoadCertificateRequest) GetKeyPair() *KeyPair {
	if m != nil {
		return m.KeyPair
	}
	return nil
}

func (m *LoadCertificateRequest) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *LoadCertificateRequest) GetCaCertificates() []*Certificate {
	if m != nil {
		return m.CaCertificates
	}
	return nil
}

// Response from target after Loading a Certificate.
// If the target could not load the certificate, it must end the RPC stream with
// a suitable RPC error about why the Certificate was not loaded.
type LoadCertificateResponse struct {
}

func (m *LoadCertificateResponse) Reset()                    { *m = LoadCertificateResponse{} }
func (m *LoadCertificateResponse) String() string            { return proto.CompactTextString(m) }
func (*LoadCertificateResponse) ProtoMessage()               {}
func (*LoadCertificateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// A Finalize message is sent to the target to confirm the Rotation of
// the certificate and that the certificate should not be rolled back when
// the RPC concludes. The certificate must be rolled back if the target returns
// an error after receiving a Finalize message.
type FinalizeRequest struct {
}

func (m *FinalizeRequest) Reset()                    { *m = FinalizeRequest{} }
func (m *FinalizeRequest) String() string            { return proto.CompactTextString(m) }
func (*FinalizeRequest) ProtoMessage()               {}
func (*FinalizeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// The request to query all the certificates on the target.
type GetCertificatesRequest struct {
}

func (m *GetCertificatesRequest) Reset()                    { *m = GetCertificatesRequest{} }
func (m *GetCertificatesRequest) String() string            { return proto.CompactTextString(m) }
func (*GetCertificatesRequest) ProtoMessage()               {}
func (*GetCertificatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// Response from the target about the certificates that exist on the target what
// what is using them.
type GetCertificatesResponse struct {
	CertificateInfo []*CertificateInfo `protobuf:"bytes,1,rep,name=certificate_info,json=certificateInfo" json:"certificate_info,omitempty"`
}

func (m *GetCertificatesResponse) Reset()                    { *m = GetCertificatesResponse{} }
func (m *GetCertificatesResponse) String() string            { return proto.CompactTextString(m) }
func (*GetCertificatesResponse) ProtoMessage()               {}
func (*GetCertificatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetCertificatesResponse) GetCertificateInfo() []*CertificateInfo {
	if m != nil {
		return m.CertificateInfo
	}
	return nil
}

type CertificateInfo struct {
	CertificateId string       `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
	Certificate   *Certificate `protobuf:"bytes,2,opt,name=certificate" json:"certificate,omitempty"`
	// List of endpoints using this certificate.
	Endpoints []*Endpoint `protobuf:"bytes,3,rep,name=endpoints" json:"endpoints,omitempty"`
	// System modification time when the certificate was installed/rotated in
	// nanoseconds since epoch.
	ModificationTime int64 `protobuf:"varint,4,opt,name=modification_time,json=modificationTime" json:"modification_time,omitempty"`
}

func (m *CertificateInfo) Reset()                    { *m = CertificateInfo{} }
func (m *CertificateInfo) String() string            { return proto.CompactTextString(m) }
func (*CertificateInfo) ProtoMessage()               {}
func (*CertificateInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CertificateInfo) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *CertificateInfo) GetCertificate() *Certificate {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *CertificateInfo) GetEndpoints() []*Endpoint {
	if m != nil {
		return m.Endpoints
	}
	return nil
}

func (m *CertificateInfo) GetModificationTime() int64 {
	if m != nil {
		return m.ModificationTime
	}
	return 0
}

type RevokeCertificatesRequest struct {
	// Certificates to revoke.
	CertificateId []string `protobuf:"bytes,1,rep,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
}

func (m *RevokeCertificatesRequest) Reset()                    { *m = RevokeCertificatesRequest{} }
func (m *RevokeCertificatesRequest) String() string            { return proto.CompactTextString(m) }
func (*RevokeCertificatesRequest) ProtoMessage()               {}
func (*RevokeCertificatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RevokeCertificatesRequest) GetCertificateId() []string {
	if m != nil {
		return m.CertificateId
	}
	return nil
}

type RevokeCertificatesResponse struct {
	// List of certificates successfully revoked.
	RevokedCertificateId []string `protobuf:"bytes,1,rep,name=revoked_certificate_id,json=revokedCertificateId" json:"revoked_certificate_id,omitempty"`
	// List of errors why certain certificates could not be revoked.
	CertificateRevocationError []*CertificateRevocationError `protobuf:"bytes,2,rep,name=certificate_revocation_error,json=certificateRevocationError" json:"certificate_revocation_error,omitempty"`
}

func (m *RevokeCertificatesResponse) Reset()                    { *m = RevokeCertificatesResponse{} }
func (m *RevokeCertificatesResponse) String() string            { return proto.CompactTextString(m) }
func (*RevokeCertificatesResponse) ProtoMessage()               {}
func (*RevokeCertificatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RevokeCertificatesResponse) GetRevokedCertificateId() []string {
	if m != nil {
		return m.RevokedCertificateId
	}
	return nil
}

func (m *RevokeCertificatesResponse) GetCertificateRevocationError() []*CertificateRevocationError {
	if m != nil {
		return m.CertificateRevocationError
	}
	return nil
}

// An error message indicating why a certificate id could not be revoked.
type CertificateRevocationError struct {
	CertificateId string `protobuf:"bytes,1,opt,name=certificate_id,json=certificateId" json:"certificate_id,omitempty"`
	ErrorMessage  string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage" json:"error_message,omitempty"`
}

func (m *CertificateRevocationError) Reset()                    { *m = CertificateRevocationError{} }
func (m *CertificateRevocationError) String() string            { return proto.CompactTextString(m) }
func (*CertificateRevocationError) ProtoMessage()               {}
func (*CertificateRevocationError) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *CertificateRevocationError) GetCertificateId() string {
	if m != nil {
		return m.CertificateId
	}
	return ""
}

func (m *CertificateRevocationError) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// A request to ask the target if it can generate key pairs.
type CanGenerateCSRRequest struct {
	KeyType         KeyType         `protobuf:"varint,1,opt,name=key_type,json=keyType,enum=gnoi.certificate.KeyType" json:"key_type,omitempty"`
	CertificateType CertificateType `protobuf:"varint,2,opt,name=certificate_type,json=certificateType,enum=gnoi.certificate.CertificateType" json:"certificate_type,omitempty"`
	KeySize         uint32          `protobuf:"varint,3,opt,name=key_size,json=keySize" json:"key_size,omitempty"`
}

func (m *CanGenerateCSRRequest) Reset()                    { *m = CanGenerateCSRRequest{} }
func (m *CanGenerateCSRRequest) String() string            { return proto.CompactTextString(m) }
func (*CanGenerateCSRRequest) ProtoMessage()               {}
func (*CanGenerateCSRRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CanGenerateCSRRequest) GetKeyType() KeyType {
	if m != nil {
		return m.KeyType
	}
	return KeyType_KT_UNKNOWN
}

func (m *CanGenerateCSRRequest) GetCertificateType() CertificateType {
	if m != nil {
		return m.CertificateType
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CanGenerateCSRRequest) GetKeySize() uint32 {
	if m != nil {
		return m.KeySize
	}
	return 0
}

// Response from the target about whether it can generate a CSR with the given
// parameters.
type CanGenerateCSRResponse struct {
	CanGenerate bool `protobuf:"varint,4,opt,name=can_generate,json=canGenerate" json:"can_generate,omitempty"`
}

func (m *CanGenerateCSRResponse) Reset()                    { *m = CanGenerateCSRResponse{} }
func (m *CanGenerateCSRResponse) String() string            { return proto.CompactTextString(m) }
func (*CanGenerateCSRResponse) ProtoMessage()               {}
func (*CanGenerateCSRResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CanGenerateCSRResponse) GetCanGenerate() bool {
	if m != nil {
		return m.CanGenerate
	}
	return false
}

// A certificate.
type Certificate struct {
	// Type of certificate.
	Type CertificateType `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Actual certificate.
	// The exact encoding depends upon the type of certificate.
	// for X509, this should be a PEM encoded Certificate.
	Certificate []byte `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *Certificate) Reset()                    { *m = Certificate{} }
func (m *Certificate) String() string            { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()               {}
func (*Certificate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Certificate) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *Certificate) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

// A Certificate Signing Request.
type CSR struct {
	// Type of certificate.
	Type CertificateType `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.CertificateType" json:"type,omitempty"`
	// Bytes representing the CSR.
	// The exact encoding depends upon the type of certificate requested.
	// for X509: This should be the PEM encoded CSR.
	Csr []byte `protobuf:"bytes,2,opt,name=csr,proto3" json:"csr,omitempty"`
}

func (m *CSR) Reset()                    { *m = CSR{} }
func (m *CSR) String() string            { return proto.CompactTextString(m) }
func (*CSR) ProtoMessage()               {}
func (*CSR) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *CSR) GetType() CertificateType {
	if m != nil {
		return m.Type
	}
	return CertificateType_CT_UNKNOWN
}

func (m *CSR) GetCsr() []byte {
	if m != nil {
		return m.Csr
	}
	return nil
}

// A message representing a pair of public/private keys.
type KeyPair struct {
	PrivateKey []byte `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	PublicKey  []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *KeyPair) Reset()                    { *m = KeyPair{} }
func (m *KeyPair) String() string            { return proto.CompactTextString(m) }
func (*KeyPair) ProtoMessage()               {}
func (*KeyPair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *KeyPair) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *KeyPair) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// An endpoint represents an entity on the target which can use a certificate.
type Endpoint struct {
	Type Endpoint_Type `protobuf:"varint,1,opt,name=type,enum=gnoi.certificate.Endpoint_Type" json:"type,omitempty"`
	// Human readable identifier for an endpoint.
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint" json:"endpoint,omitempty"`
}

func (m *Endpoint) Reset()                    { *m = Endpoint{} }
func (m *Endpoint) String() string            { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()               {}
func (*Endpoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Endpoint) GetType() Endpoint_Type {
	if m != nil {
		return m.Type
	}
	return Endpoint_EP_UNSPECIFIED
}

func (m *Endpoint) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func init() {
	proto.RegisterType((*RotateCertificateRequest)(nil), "gnoi.certificate.RotateCertificateRequest")
	proto.RegisterType((*RotateCertificateResponse)(nil), "gnoi.certificate.RotateCertificateResponse")
	proto.RegisterType((*InstallCertificateRequest)(nil), "gnoi.certificate.InstallCertificateRequest")
	proto.RegisterType((*InstallCertificateResponse)(nil), "gnoi.certificate.InstallCertificateResponse")
	proto.RegisterType((*GenerateCSRRequest)(nil), "gnoi.certificate.GenerateCSRRequest")
	proto.RegisterType((*CSRParams)(nil), "gnoi.certificate.CSRParams")
	proto.RegisterType((*GenerateCSRResponse)(nil), "gnoi.certificate.GenerateCSRResponse")
	proto.RegisterType((*LoadCertificateRequest)(nil), "gnoi.certificate.LoadCertificateRequest")
	proto.RegisterType((*LoadCertificateResponse)(nil), "gnoi.certificate.LoadCertificateResponse")
	proto.RegisterType((*FinalizeRequest)(nil), "gnoi.certificate.FinalizeRequest")
	proto.RegisterType((*GetCertificatesRequest)(nil), "gnoi.certificate.GetCertificatesRequest")
	proto.RegisterType((*GetCertificatesResponse)(nil), "gnoi.certificate.GetCertificatesResponse")
	proto.RegisterType((*CertificateInfo)(nil), "gnoi.certificate.CertificateInfo")
	proto.RegisterType((*RevokeCertificatesRequest)(nil), "gnoi.certificate.RevokeCertificatesRequest")
	proto.RegisterType((*RevokeCertificatesResponse)(nil), "gnoi.certificate.RevokeCertificatesResponse")
	proto.RegisterType((*CertificateRevocationError)(nil), "gnoi.certificate.CertificateRevocationError")
	proto.RegisterType((*CanGenerateCSRRequest)(nil), "gnoi.certificate.CanGenerateCSRRequest")
	proto.RegisterType((*CanGenerateCSRResponse)(nil), "gnoi.certificate.CanGenerateCSRResponse")
	proto.RegisterType((*Certificate)(nil), "gnoi.certificate.Certificate")
	proto.RegisterType((*CSR)(nil), "gnoi.certificate.CSR")
	proto.RegisterType((*KeyPair)(nil), "gnoi.certificate.KeyPair")
	proto.RegisterType((*Endpoint)(nil), "gnoi.certificate.Endpoint")
	proto.RegisterEnum("gnoi.certificate.CertificateType", CertificateType_name, CertificateType_value)
	proto.RegisterEnum("gnoi.certificate.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("gnoi.certificate.Endpoint_Type", Endpoint_Type_name, Endpoint_Type_value)
}

func init() { proto.RegisterFile("github.com/openconfig/gnoi/cert/cert.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1255 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xdd, 0x72, 0xda, 0xc6,
	0x17, 0xb7, 0x0c, 0x31, 0x70, 0xc0, 0x20, 0x6f, 0x12, 0x47, 0xf0, 0xff, 0x67, 0x92, 0xa8, 0xcd,
	0xc4, 0x71, 0x32, 0xd8, 0xcd, 0xc7, 0x4c, 0x3f, 0x66, 0xdc, 0xb1, 0x09, 0x8e, 0x19, 0x6c, 0xc2,
	0x08, 0xdc, 0xf6, 0x4e, 0xb3, 0x16, 0x0b, 0xde, 0x31, 0xda, 0x55, 0x25, 0x39, 0x1d, 0xfc, 0x10,
	0x7d, 0x81, 0xde, 0xf4, 0xaa, 0x8f, 0xd0, 0x07, 0xe8, 0x13, 0x74, 0x3a, 0x9d, 0x5e, 0xf7, 0x49,
	0x3a, 0x1d, 0xed, 0x0a, 0x10, 0x48, 0xd8, 0x34, 0x77, 0xb9, 0x61, 0xa4, 0x73, 0x7e, 0xe7, 0xb7,
	0x7b, 0xbe, 0x05, 0x6c, 0x0f, 0xa8, 0x7f, 0x7e, 0x79, 0x56, 0xb5, 0xb8, 0xbd, 0xc3, 0x1d, 0xc2,
	0x2c, 0xce, 0xfa, 0x74, 0xb0, 0x33, 0x60, 0x9c, 0xee, 0x58, 0xc4, 0xf5, 0xc5, 0x4f, 0xd5, 0x71,
	0xb9, 0xcf, 0x91, 0x1a, 0x48, 0xab, 0x81, 0x80, 0xf6, 0xa9, 0x85, 0x7d, 0x52, 0x79, 0x7e, 0x8d,
	0xb5, 0x3f, 0x72, 0x88, 0x27, 0x7f, 0xa5, 0xbd, 0xfe, 0xf3, 0x2a, 0x68, 0x06, 0xf7, 0xb1, 0x4f,
	0x6a, 0x53, 0x0e, 0x83, 0x7c, 0x7f, 0x49, 0x3c, 0x1f, 0x35, 0xa0, 0x30, 0x20, 0x8c, 0xb8, 0xd8,
	0x27, 0xa6, 0xe5, 0xb9, 0x9a, 0xf2, 0x50, 0xd9, 0xca, 0xbf, 0xf8, 0xb4, 0x3a, 0x7f, 0x66, 0xf5,
	0x6d, 0x88, 0xaa, 0x75, 0x8c, 0xd0, 0xf6, 0x68, 0xc5, 0xc8, 0x8f, 0x6d, 0x6b, 0x9e, 0x8b, 0x4e,
	0x41, 0x1d, 0x72, 0xdc, 0x33, 0x23, 0x56, 0xda, 0xaa, 0xa0, 0xdb, 0x8a, 0xd3, 0x1d, 0x73, 0xdc,
	0x8b, 0x5f, 0xe7, 0x68, 0xc5, 0x28, 0x0d, 0x67, 0x35, 0xa8, 0x0d, 0x1b, 0x7d, 0xca, 0xf0, 0x90,
	0x5e, 0x11, 0xd3, 0x0d, 0xdc, 0xa0, 0x9c, 0x69, 0x29, 0xc1, 0xfb, 0x28, 0xce, 0x7b, 0x18, 0x42,
	0xa7, 0x84, 0xea, 0xd8, 0xda, 0x08, 0x8d, 0x0f, 0x54, 0x28, 0x0a, 0x22, 0x62, 0xba, 0x12, 0xa5,
	0xff, 0xa9, 0x40, 0x39, 0x21, 0x44, 0x9e, 0xc3, 0x99, 0x47, 0xd0, 0x31, 0xac, 0x8f, 0xfd, 0xec,
	0x45, 0x82, 0xf4, 0xf8, 0x86, 0x20, 0x49, 0xeb, 0xa3, 0x15, 0x63, 0x12, 0xe1, 0x5e, 0x10, 0xa6,
	0x6f, 0x16, 0x86, 0xe9, 0xe9, 0x12, 0x61, 0x9a, 0x90, 0xce, 0xc7, 0xe9, 0x60, 0x03, 0x4a, 0x13,
	0xaf, 0x24, 0x4a, 0xff, 0x5d, 0x81, 0x72, 0x83, 0x79, 0x3e, 0x1e, 0x0e, 0x3f, 0xc6, 0xd4, 0x07,
	0x2e, 0x51, 0x79, 0xfd, 0x49, 0xa6, 0xfe, 0x52, 0xa0, 0x92, 0xe4, 0xd2, 0x47, 0x95, 0x2a, 0x04,
	0xea, 0xd4, 0xaf, 0x30, 0x57, 0x3f, 0x00, 0x8a, 0xc7, 0x19, 0x7d, 0x09, 0x60, 0x79, 0xae, 0xe9,
	0x60, 0x17, 0xdb, 0x5e, 0xe8, 0xcc, 0xff, 0xe2, 0x67, 0xd7, 0x3a, 0x46, 0x5b, 0x40, 0x8c, 0x9c,
	0xe5, 0xb9, 0xf2, 0x11, 0x3d, 0x86, 0x62, 0x04, 0x63, 0xd2, 0x9e, 0xb8, 0x7b, 0xce, 0x58, 0x8f,
	0x48, 0x1b, 0x3d, 0xfd, 0xc7, 0x14, 0xe4, 0x26, 0xf6, 0xe8, 0x35, 0xa4, 0x83, 0xd9, 0x21, 0x8e,
	0x2a, 0x26, 0x35, 0x58, 0xc4, 0x8f, 0xee, 0xc8, 0x21, 0x86, 0x80, 0xa3, 0x87, 0x50, 0xb0, 0x29,
	0x33, 0x2f, 0xc8, 0xc8, 0xf4, 0xe8, 0x95, 0x8c, 0xd2, 0xba, 0x01, 0x36, 0x65, 0x4d, 0x32, 0xea,
	0xd0, 0x2b, 0x82, 0x5e, 0x41, 0x36, 0xd0, 0x0a, 0xf2, 0x94, 0x20, 0x2f, 0xc7, 0xc9, 0x9b, 0x64,
	0x24, 0x48, 0x33, 0x17, 0xf2, 0x01, 0x3d, 0x80, 0xbc, 0xc5, 0x6d, 0x9b, 0x33, 0x93, 0x61, 0x9b,
	0x68, 0x69, 0xe1, 0x00, 0x48, 0x51, 0x0b, 0xdb, 0x04, 0x69, 0x90, 0xb1, 0xf8, 0x25, 0xf3, 0xdd,
	0x91, 0x76, 0x4b, 0x28, 0xc7, 0xaf, 0xe8, 0x0e, 0xdc, 0xf2, 0x82, 0x76, 0xd0, 0xd6, 0x84, 0x5c,
	0xbe, 0x20, 0x04, 0x69, 0x8b, 0xfa, 0x23, 0x2d, 0x23, 0x84, 0xe2, 0x19, 0xe9, 0x50, 0xe0, 0xee,
	0x00, 0x33, 0x7a, 0x25, 0x87, 0x4b, 0x56, 0xe8, 0x66, 0x64, 0x68, 0x07, 0x6e, 0x47, 0xdf, 0xf1,
	0xd0, 0xbc, 0x64, 0xd4, 0xd7, 0x72, 0x02, 0x8a, 0x66, 0x55, 0xa7, 0x8c, 0xfa, 0xe8, 0x3e, 0x00,
	0x75, 0x4c, 0xdc, 0xeb, 0xb9, 0xc4, 0xf3, 0x34, 0x10, 0xb8, 0x1c, 0x75, 0xf6, 0xa5, 0x00, 0x95,
	0x21, 0x4b, 0x6c, 0x4c, 0x87, 0x41, 0x5a, 0xf2, 0xf2, 0xe2, 0xe2, 0xbd, 0xd1, 0xd3, 0xf7, 0xe0,
	0x76, 0x42, 0x71, 0xa2, 0x27, 0x90, 0x9a, 0x16, 0xf4, 0xdd, 0xc4, 0x1a, 0x30, 0x02, 0x84, 0xfe,
	0x8f, 0x02, 0x9b, 0xc9, 0x3d, 0x86, 0xbe, 0x86, 0x7c, 0xb4, 0x96, 0x25, 0xd7, 0xfd, 0x6b, 0x93,
	0x6c, 0x44, 0x2d, 0xc6, 0x59, 0x74, 0x30, 0x75, 0xc3, 0x4e, 0x48, 0xce, 0x62, 0x1b, 0x53, 0x57,
	0x64, 0x31, 0x78, 0x48, 0xa8, 0xc4, 0x54, 0x42, 0x25, 0xa2, 0x43, 0x28, 0x59, 0x38, 0xda, 0x6c,
	0x9e, 0x96, 0x7e, 0x98, 0xba, 0xf9, 0x86, 0x45, 0x0b, 0x47, 0x5e, 0x3d, 0xbd, 0x0c, 0xf7, 0x16,
	0x34, 0xa3, 0xbe, 0x01, 0xa5, 0xb9, 0x0d, 0xa1, 0x6b, 0xb0, 0xf9, 0x96, 0xf8, 0x51, 0x82, 0xb1,
	0x66, 0x00, 0xf7, 0x62, 0x9a, 0xc9, 0x9c, 0x51, 0x67, 0x3c, 0x62, 0x7d, 0xae, 0x29, 0xe2, 0xae,
	0xd7, 0xb7, 0x4c, 0x83, 0xf5, 0xb9, 0x51, 0xb2, 0x66, 0x05, 0xfa, 0xdf, 0x0a, 0x94, 0xe6, 0x40,
	0x09, 0x31, 0x53, 0x92, 0x62, 0x36, 0x97, 0xd1, 0xd5, 0xff, 0x9c, 0xd1, 0xcf, 0x21, 0x47, 0x58,
	0xcf, 0xe1, 0x94, 0xf9, 0x9e, 0x96, 0x12, 0x2e, 0x54, 0xe2, 0xe6, 0xf5, 0x10, 0x62, 0x4c, 0xc1,
	0xe8, 0x19, 0x6c, 0xd8, 0xbc, 0x27, 0x11, 0x94, 0x33, 0xd3, 0xa7, 0x61, 0x87, 0xa6, 0x0c, 0x35,
	0xaa, 0xe8, 0x52, 0x9b, 0xe8, 0x07, 0x50, 0x36, 0xc8, 0x7b, 0x7e, 0x41, 0x12, 0x02, 0x9d, 0xe8,
	0x6b, 0x2a, 0x3e, 0xa9, 0x7e, 0x53, 0xa0, 0x92, 0x44, 0x12, 0xe6, 0xe4, 0x15, 0x6c, 0xba, 0x42,
	0x3b, 0x33, 0xb0, 0xa7, 0x6c, 0x77, 0x42, 0x6d, 0x6d, 0x26, 0x80, 0x0c, 0xfe, 0x1f, 0x45, 0x07,
	0x98, 0xd0, 0x1f, 0xe2, 0xba, 0x3c, 0xa8, 0xf2, 0x20, 0x24, 0xcf, 0xaf, 0x8f, 0xe8, 0xc4, 0xa8,
	0x1e, 0xd8, 0x18, 0x15, 0x6b, 0xa1, 0x4e, 0x3f, 0x87, 0xca, 0x62, 0xcb, 0x65, 0xb3, 0xfe, 0x09,
	0xac, 0x8b, 0xdb, 0x99, 0x36, 0xf1, 0x3c, 0x3c, 0x20, 0xe1, 0x64, 0x2f, 0x08, 0xe1, 0x89, 0x94,
	0xe9, 0xbf, 0x2a, 0x70, 0xb7, 0x86, 0x59, 0xc2, 0x56, 0x89, 0xce, 0x62, 0x65, 0xe9, 0x59, 0x3c,
	0x57, 0xf3, 0xc2, 0x7a, 0x75, 0xd9, 0x35, 0x11, 0xad, 0x79, 0xc1, 0x56, 0x96, 0x77, 0x10, 0xdb,
	0x22, 0x25, 0xb6, 0x45, 0x70, 0x50, 0xb0, 0x2a, 0xf4, 0xaf, 0x60, 0x73, 0xfe, 0xde, 0x61, 0x8a,
	0x1f, 0x41, 0xc1, 0xc2, 0xcc, 0x1c, 0x2f, 0x69, 0x51, 0x6d, 0x59, 0x23, 0x6f, 0x4d, 0xd1, 0x7a,
	0x1f, 0xf2, 0xd1, 0xaf, 0xc7, 0x0f, 0xde, 0x67, 0xb1, 0xb6, 0x2a, 0xcc, 0xf4, 0x8d, 0xde, 0x82,
	0x54, 0xad, 0x63, 0x7c, 0x28, 0xbf, 0x2a, 0x87, 0xb9, 0xe4, 0x15, 0x53, 0xbb, 0x01, 0x99, 0x70,
	0x6e, 0x06, 0x4b, 0xcf, 0x71, 0xe9, 0xfb, 0x20, 0xc8, 0x17, 0x64, 0x24, 0xa8, 0x0b, 0x06, 0x84,
	0xa2, 0x26, 0x19, 0x05, 0xbb, 0xc5, 0xb9, 0x3c, 0x1b, 0x52, 0x4b, 0xe8, 0x25, 0x49, 0x4e, 0x4a,
	0x9a, 0x64, 0xa4, 0xff, 0xa4, 0x40, 0x76, 0xdc, 0xb0, 0xe8, 0xe5, 0xcc, 0x05, 0x1f, 0x2c, 0x6e,
	0xed, 0x6a, 0xe4, 0x7a, 0x15, 0xc8, 0x8e, 0xfb, 0x3c, 0x2c, 0xad, 0xc9, 0xbb, 0xbe, 0x07, 0x69,
	0x91, 0x40, 0x04, 0xc5, 0x7a, 0xdb, 0x3c, 0x6d, 0x75, 0xda, 0xf5, 0x5a, 0xe3, 0xb0, 0x51, 0x7f,
	0xa3, 0xae, 0xa0, 0xdb, 0x50, 0xaa, 0xb7, 0xcd, 0x46, 0xbb, 0x53, 0xaf, 0x99, 0xdd, 0xd3, 0x56,
	0xab, 0x7e, 0xac, 0x2a, 0x68, 0x1d, 0x72, 0xf5, 0xb6, 0xf9, 0x66, 0xbf, 0x7e, 0xf2, 0xae, 0xa5,
	0xae, 0x6e, 0x57, 0x67, 0x66, 0x9d, 0xa0, 0x2a, 0x02, 0xd4, 0xba, 0xe6, 0x69, 0xab, 0xd9, 0x7a,
	0xf7, 0x6d, 0x4b, 0x5d, 0x41, 0x79, 0xc8, 0xd4, 0xba, 0xe6, 0x77, 0xaf, 0x77, 0xbf, 0x50, 0x95,
	0xed, 0xc7, 0x22, 0x30, 0x63, 0x5c, 0x33, 0x8a, 0x03, 0x58, 0x6b, 0x76, 0x4d, 0xa3, 0xb3, 0xaf,
	0x2a, 0x2f, 0x7e, 0x49, 0xc3, 0xdd, 0x08, 0xef, 0x09, 0x66, 0x78, 0x40, 0x6c, 0xc2, 0x7c, 0x44,
	0x60, 0x4d, 0x7e, 0xdb, 0xa3, 0xed, 0xb8, 0xf7, 0x8b, 0xfe, 0x18, 0x55, 0x9e, 0x2d, 0x85, 0x95,
	0x75, 0xb9, 0xa5, 0xec, 0x2a, 0xe8, 0x1c, 0x32, 0xe1, 0x87, 0x29, 0x4a, 0xb0, 0x5d, 0xf8, 0x19,
	0x5e, 0x79, 0xbe, 0x1c, 0x38, 0x72, 0x52, 0x1f, 0x4a, 0x73, 0x7b, 0x09, 0x6d, 0x25, 0x7d, 0xe0,
	0x26, 0x2d, 0xb5, 0xca, 0xd3, 0x25, 0x90, 0x61, 0xb7, 0x71, 0x40, 0xf1, 0x71, 0x9b, 0xe4, 0xdc,
	0xc2, 0xc9, 0x9e, 0xe4, 0xdc, 0x35, 0x13, 0xdc, 0x82, 0xe2, 0x6c, 0xe3, 0xa3, 0x27, 0x09, 0x0d,
	0x95, 0x34, 0xd2, 0x2a, 0x5b, 0x37, 0x03, 0xe5, 0x21, 0x07, 0xd9, 0x3f, 0xf6, 0x6e, 0xed, 0x56,
	0x3f, 0xab, 0xee, 0x9e, 0xad, 0x89, 0xff, 0xc7, 0x2f, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x26,
	0x46, 0x94, 0x5e, 0x8d, 0x0f, 0x00, 0x00,
}
